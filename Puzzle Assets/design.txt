Bryan Dumond
Fall 2021 - CS 5001
Final Project design.txt


    One of Khoury College's biggest draws for me was the fact that it offered
    
programming courses in game development, so I was extremely excited to get a

taste of that with this project. Making even a game as tiny as this taught

me how much of a virtue patience is in game dev!


    For my design, I decided to make a Tile class and a Board class, along with
    
some global functions that can interact with both. I did this both because I

wanted to challenge myself with OOD and because I wanted to get into the habit of

making modular functions that can be used across multiple projects, not just one

(my create_shuffled_indices from HW4 proved super useful in this project,

 basically untouched). 


    The general flow of my program is that main() sets up the Turtle window,

and then 'initial_setup' becomes the driver that draws the game space, creates

the Board class and gets the leaderboards. From there, the Board class' init

automatically calls the functions that validate .puz files and create Tile

objects, among other things. To keep track of the game logic, I created within

the Board class a nested list to mimic a 2D grid. A 4x4 board, for example, would

be 1 list containing four lists each of length 4. Each nested list contained 

Tile objects, making it very easy to identify Tile objects by their indices and 

check for validity of moves.


    For the turtle portion, I had an outliner turtle within the Board class

draw out the square outlines that were to be filled by Tile images. I had it 

migrate to the square centers, store those coordinates, and pass them to my Tile

objects so they'd know where to draw themselves. That Turtle Screen information is 

among the few pieces of data transferred between Tile objects upon a successful move.

Essentially, the Board instance feeds Tile objects the metadata they need

in order to execute their methods: if Tiles are like musicians with their own

unique talents, the Board is the conductor that tells them how to work together

as a whole. The rest of the non-game-specific (leaderboard, buttons, outlines) tasks

are controlled by the general functions: they'd be stagehands, in this analogy. 


    There are some advantages to this approach. For example, I fully

believe that debugging was much easier in the long run: the shell messages that

still print to the screen & give player feedback were crucial in both hunting 

down errors and improving game feel for the player, which were possible because 

of how much reference data my Board & Tile instances held. This also helped my

error logger messages be as specific as possible. I also think it drastically

improves game feel for the player to see in the shell which Tile they clicked,

where that tile exists in the nested list, and what error just happened in real

time. I also wanted to be mindful of performance and tried to re-draw the screen as

little as possible within the Board class: for example, the only Tiles that

get re-drawn after a successful move are the two that were switched. An earlier 

iteration did have my Board re-draw the screen after each move, which resulted 

in a near 1000 millisecond delay between a click and a tile move. I'm glad I 

moved away from this route.


    There are some small side effects of setting up the game this way.

For example, since .puz files are validated in the init of a Board class, 

loading a new board always erases the current one, even if the one to be

loaded is broken/malformed. I suspect this might have something to do with

puzzle validation being tied to my Board class' init rather than a separate,

outside function. Additionally, I did end up using some global functions, 

though thankfully only two of them (Screen and my Board instance) were rather 

memory intensive. Hopefully CD 5004 will further show me how to design OO programs 

with less global variables and more modularity.


Other program specific features / highlights:

- Both 'Moves Made' and 'Moves Left' are displayed to the user, and when user
  has less than 3 moves left, that text glows red as a warning.

- All turtles/drawings are cleared from the screen once an endgame state (win or
  lose) has been reached. This is mainly done to prevent players from continuing
  to click tiles after an endgame has been reached while still being able to 
  display a credits page.

- When a user loads an invalid puzzle, dismissing the error message automatically
  brings them back to the .puz file input text box. User is allowed to cancel
  if they wish, but a failed load is designed to prompt again.

- "New High Score" is printed to the screen when a user either has the highest
  score in the leaderboard text or a text file doesn't yet exist.

- For sake of clarity, only first 18 Slots of Leaderboard are drawn to the screen.
  Leaders ARE still saved even if not displayed, however.

- Player names are designed to only be 4 characters max to keep the board from
  getting too cluttered. Defaults to "USER" if player presses cancel, and move
  count defaults to 10 if player presses cancel.

- Players who tie someone on the leaderboard are given the same place number.
  However, the "High Score" text ONLY displays when the user's score is higher
  than anyone else's. Tying for high score does not prompt the High Score text.



    Overall, I'm very pleased with the way this turned out. I can't wait to see

what OOD has in store! Thank you Professor Bagley & Team for a great semester!
